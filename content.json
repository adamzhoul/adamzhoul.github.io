[{"title":"explain介绍","date":"2016-12-29T23:53:00.000Z","path":"2016/12/30/explain介绍/","text":"explain select …. select_type: simple primary subquery derived union union result type 表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下: all index range ref eq_ref const,system NULL","tags":[]},{"title":"location匹配规则","date":"2016-12-29T23:10:54.000Z","path":"2016/12/30/location匹配规则/","text":"location的表示：location [= | ~| ~* | \\^~ ] uri { …} 其中，uri为待匹配的请字符串，可以包含也可不包含正则。 各个标识含义： “=” 用于不包含正则uri，要求严格匹配，若已经匹配，停止匹配。使用当前这个。 “^~” 用于不包含正则的uri前，要求最前面的部分开始匹配。 “~” 区分大小写的正则匹配，可以用于正则或者非正则uri “~*” 不区分大小写的正则匹配，可以用于正则或者非正则uri location匹配优先级： 最高级：&quot;=&quot; 其次： &quot;^~“ 接下来：&quot;~&quot;,&quot;~*&quot; (顺序靠前的优先级更高) 最后： 不包含可选项“[]”的这种 (匹配度越高，优先级越高) 来自其他网站的描述（http://mark-ztw.iteye.com/blog/1564544） 1. 带”=”前缀的先进行匹配，如果找到了，中止查找。 2. 所有其它location 进行非正则的匹配，找到最精确匹配的那个，如果匹配到带”^~”前缀的，则中止查找。 3. 正则查找，按照我们配置文件中配置的location 顺序进行查找。 4. 如果正则查找匹配成功，则使用此正则匹配的location ，否则，使用第二步查找的结果。 这里要特别说明下”=”与”^~”的区别： “=”在匹配时，则匹配带”=”的location 。而”^~”，则会匹配所有非”=”的非正则location ，只有在确认它是最精确匹配的location 后，才生效。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginx模块","date":"2016-11-28T17:23:51.000Z","path":"2016/11/29/nginx模块/","text":"nginx http模块##Http模块结构 ngx_module_t ngx_http_mytest_moudules;因此，需要搞清楚数据结构：ngx_module_t 作为nginx模块的数据结构，是很抽象的，需要搞清楚具体是个什么鬼。 12345678910typedef struct ngx_module_s ngx_module_t;struct ngx_modules&#123; #define NGX_MODULE_V1 0,0,0,0,0,0,1 ngx_uint_t ctx_index; ngxinin_uint_t index; void *ctx; ngx_command_t *command; ngx_uint_t type; ...&#125; ngx_http_module 12345678910typedef struct&#123; create_main_conf create_srv_conf create_loc_conf preconfiguration init_main_conf merge_srv_conf merge_loc_conf postconfiguration&#125; commands 数组用于定义模块的配置文件参数，每一个数组元素都是ngx_command_t类型，数组的结尾用ngx_null_command表示。 123456789typedef struct ngx_command_s ngx_command_t;struct ngx_command_s&#123; ngx_str_t name; ngx_uint_t type; char *(*set)(ngx_conf_t *conf, ngx_command_t *cmd, void *conf); ngx_uint_t conf; ngx_uint_t offset; void *post;&#125; ngx_null_command 只是个空的ngx_command_t #define ngx_null_command {ngx_null_string, 0, NULL, 0, 0, NULL} #定义自己的HTTP模块 http框架定义的11个阶段（第三方模块，只能介入其中的7个）。 123456789101112131415161718192021222324typedef enum&#123; //接收到完整http头部 NGX_HTTP_POST_READ_PHASE = 0, //未定位到location，处于rewrite阶段 NGX_HTTP_SERVER_REWRITE_PHASE, //寻找location阶段（不建议第三方介入） NGX_HTTP_FIND_CONFIG_PHASE, NGX_HTTP_REWRITE_PHASE, NGX_HTTP_POSET_REWRITE_PHASE, NGX_HTTP_PREACCESS_PHASE, NGX_HTTP_ACCESS_PHASE, NGX_HTTP_POST_ACCESS_PHASE, NGX_HTTP_TRY_FILES_PHASE, NGX_HTTP_CONTENT_PHASE, NGX_HTTP_LOG_PHASE,&#125; 我们可以在任意阶段介入，比如： 123456static ngx_http_module_t ngx_http_mytest_module_ctx=&#123;NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL&#125; 定义mytest模块： 1234567891011121314ngx_module_t ngx_http_mytest_module=&#123;NGX_MODULE_V1,&amp;ngx_http_mytest_module_ctx, /* module context*/ngx_http_mytest_command, /* module directives */NGX_HTTP_MODULE, /* module_type */NULL, /* init master */NULL, /* init module */NULL, /* init process */NULL, /* init thread */NULL, /* exit thread */NULL, /* exit process */NULL, /* exit master */NGX_MODULE_V1_PADDING&#125; 小结： 1、整体流程 work进程： while(true) { if(事件模块检测到客户端发起tcp请求()) { 建立tcp连接； handleByHttp框架AccrodingToNginxConf(); } } handleByHttp框架AccrodingToNginxConf() { 试图接收到完整的http头部 分发到具体的模块中处理 http模块处理请求 请求处理结束，向客户端发送response } 向客户端发送response（） { 自动依次调用所有的HTTP过滤模块 } 2、基本数据结构 类型 变量 整形 ngx_int_t ngx_uint_t 字符串 ngx_str_t 链表容器 ngx_list_t 键值对 ngx_table_elt_t 缓冲区 ngx_buf_t 链 ngx_chain_t 3、将自己的HTTP模块编译进ngxin nginx编译增加命令： –add-module=自己模块所在路径 1）自身模块conf编写规则： ngx_add_name //模块名称 HTTP_MODULES=&quot;&quot; //所有模块名称 NGX_ADDON_SRCS=&quot;&quot; //新增模块源代码 2）编译流程 关键两个脚本： . auto/modules . auto/make $NGX_ADDONX 包含多个目录，存在config就会执行。 auto/modules 创建 ngx_modules.c文件 #配置、error日志和请求上下文 ##http配置项使用场景 配置项处理步骤： 创建数据结构，用于存储配置项对应的参数 设定配置项在ngxin.conf中出现时的限制条件和回调方法 实现回调方法，或使用nginx框架预设的14个回调方法 合并不同级别的 配置块中的同名配置项 ngx_http_module_t ngx_command_t. 存储配置项数据结构： typedef struct{ ngx_str_t my_str; ngx_int_t my_num; ngx_flag_t my_flag; size_t my_size; ngx_array_t* my_str_array; ngx_array_t* my_keyval; off_t my_off; ngx_msec_t my_msec; time_t my_sec; ngx_bufs_t my_bufs; ngx_uint_t my_enum_seq; ngx_uint_t my_bitmask; ngx_uint_t my_access; ngx_path_t my_path; } ngx_http_mytest_conf_t; ngx_http_module回顾 12345678910111213typedef struct&#123; ngx_int_t (*preconfiguration)(ngx_conf_t *cf); ngx_int_t (*postconfiguration)(ngx_conf_t *cf); void *(*create_main_conf)(ngx_conf_t *cf); char *(*init_main_conf)(ngx_conf_t *cf, void *conf); void *(*create_srv_conf)(ngx_conf_t *cf); char *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf); void *(*create_loc_conf)(ngx_conf_t *cf); char *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);&#125;ngx_http_module_t; create_main_conf、create_srv_conf、create_loc_conf 这3个回调方法负把我们分配的用于保存配置项的结构体传递给http框架。实际上，http框架，定义了三个级别的配置main srv loc ,分别对应http{} server{} location{}解析过程： 当遇到http{}配置块 http框架会调用所有http模块可能实现create_main_conf、create_srv_conf、create_loc_conf方法存储 当遇到server{}配置块 http框架会调用所有http模块可能实现create_srv_conf、create_loc_conf方法存储 当遇到location{}配置块 http框架会调用所有http模块可能实现create_loc_conf方法存储 ngx_command_t 结构回顾 typedef struct ngx_command_s ngx_command_t; } ps:记录一个碉堡了的宏： #define offset(type, member) (size_t)&amp;(((type *)0)-&gt;member). 将0地址，转换成type结构体类型指针，并在访问member时取得member成员的指针，这个指针相对于0地址来说，自然就是成员相对于结构体的偏移量了。 使用例子： static ngx_command_t ngx_http_mytest_commands[]={ ... { ngx_string(&quot;test_myconfig&quot;), NGX_HTTP_LOC_CONF|NGX_CONF_TAKE12, ngx_conf_set_myconfig, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL }, ngx_null_command } 合并配置 Http配置模型 ngx_http_conf_ctx_t 结构包括了所有HTTP模块的配置数据结构的入口。 ngx_http_upstream_t结构体 typedef struct ngx_http_upstream_s ngx_http_upstream_t; struct ngx_http_upstream_s{ //*request_bufs决定发送什么样的请求给上游服务器，在实现create_request方法时需要设置它。 ngx_chain_t *request_bufs; ngx_http_upstream_conf_t *conf;//限制参数 ngx_http_upstream_resolved_t *resolved;//通过resolved可以直接指定上有服务器地址。 ngx_buf_t buffer;//存储上有服务器发来的相应内容。 ngx_int_t (*create_request)(ngx_http_request_t *r);//构造发往上游服务器的内容 ngx_int_t (*process_header)(ngx_http_request_t *r);//收到上游服务器的相应后，就会回调此方法。 void（*finalize_request)(ngx_http_request_t *r,ngx_int rc);//销毁upstream请求时调用 ... } 其中，还有剩余的5个回调方法(input_filter_init、input_filter、reinit_request、abort_request、rewrite_redirect)，是可选的。 upstream限制性参数： typedef struct{ ... //连接上游服务器的超时时间，时间毫秒 ngx_msec_t connect_timeout; //发送TCP包，到上游服务器的超时时间，毫秒 ngx_msec_t send_timeout; //接收tcp包到上游服务器的超时时间，毫秒 ngx_msec_t read_timeout; ... } page160,方法，可以通过非常简单的ngxin.conf 配置文件，设置http_upstream_conf_t结构体。1、将结构体类型的变量，放到http_conf_t中；2、设置command[]，是的nginx.conf中的配置项放入http_conf_t中的对应变量中。3、在实际请求时，只要把nginx_conf_t配置项对应的成员变量赋给ngx_http_upstream_t中。通过handler方法。 #upstream实例 location /test{ mytest; } 功能：mytest模块使用upstream机制向google发送请求并返回转给用户。 #http过滤模块主要就是2个指针，header body其他和普通模块一样。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"我的vimrc配置","date":"2016-07-29T11:32:15.000Z","path":"2016/07/29/我的vimrc配置/","text":"配置 配置的形成非一朝一夕，也在网上借鉴了各位大神的配置还在持续完善中。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232\"插件配置let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'let Tlist_Exit_OnlyWindow = 1let Tlist_Use_Right_Window = 1 \"右侧显示let Tlist_File_Fold_Auto_Clost = 1 \"自动折叠非编辑文件set cscopequickfix=s-,c-,d-,i-,t-,e-\"================设置wim＋nerdtree+taglist===========let g:NERDTree_title='NERD Tree'let g:winManagerWindowLayout='NERDTree|TagList'\"\"let g:winManagerWindowLayout='FileExplorer|TagList'function! NERDTree_Start() exec 'NERDTree'endfunctionfunction! NERDTree_IsValid() return 1endfunctionnmap &lt;silent&gt; mt :if IsWinManagerVisible() &lt;BAR&gt; WMToggle&lt;CR&gt; &lt;BAR&gt; else &lt;BAR&gt; WMToggle&lt;CR&gt;:q&lt;CR&gt; endif &lt;CR&gt; nmap wm :WMToggle&lt;cr&gt;let g:bufExplorerMaxHeight=30\"=============超级给力的映射，直接通过热键打开窗口\"nmap file :NERDTree&lt;cr&gt;nmap list :Tlist&lt;cr&gt;&lt;TAB&gt;j&lt;TAB&gt;l&lt;TAB&gt;l&lt;TAB&gt;lnnoremap file :NERDTree&lt;cr&gt;\"nnoremap list :Tlist&lt;cr&gt;nmap qu :q&lt;cr&gt;nmap qq :q!&lt;cr&gt;nmap sa :w&lt;cr&gt;nmap wq :x&lt;cr&gt;noremap &lt;tab&gt;n :bn&lt;CR&gt;noremap &lt;tab&gt;b :bp&lt;CR&gt;nmap go &lt;C-]&gt;nmap ba &lt;C-t&gt;\"\"let g:miniBufExplorerMoreThanOne=0\"\"nmap file:NERDTree&lt;cr&gt;\"\"nmap &lt;A&gt;h :vertical res-5&lt;cr&gt;\"\"nmap &lt;A&gt;j :res+5&lt;cr&gt;\"==================编程语法格式======================syntax on \"自动语法高亮set autoindentset smartindentset tabstop=4set softtabstop=4set shiftwidth=4set noexpandtab \"不用空格代替制表符\"vim配置set number \"设置行号set relativenumber \"设置相对行号\"上面两个，在vim7.4以前没办法一起生效。\"下面的映射可以在折行的情况下，上下走，而不跳过noremap &lt;silent&gt; &lt;expr&gt; j (v:count == 0 ? 'gj' : 'j')noremap &lt;silent&gt; &lt;expr&gt; k (v:count == 0 ? 'gk' : 'k')set showmatch \"高亮显示对应的括号set showcmd \"状态行显示目前所执行的命令\"set cmdheight=1 \"设置底下命令行的高度\"set laststatus=2 \"总是显示状态行\"\"colorscheme molokai\"设置折叠\"set foldenable \"开始折叠\"set foldmethod=syntax \"设置语法折叠set foldcolumn=0 \"设置折叠区域宽度setlocal foldlevel=1 \"设置折叠层数为1set foldlevelstart=99 \"打开文件时默认不折叠代码\"set foldclose=all \"设置为主动封闭折叠\"nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt; \"用空格去折叠、展开set ignorecase smartcase \"搜索时忽略大小写\"set noignorecaseset hlsearch \"搜索时候高亮选择set incsearch \"搜索逐字符高亮set cursorline \"设置下划线\"set cursorcolumn \"设置竖线\"set nocursorline\"==================自定义的键映射======================\"括号自动生成\"vnoremap $1 &lt;esc&gt;`&gt;a)&lt;esc&gt;`&lt;i(&lt;esc&gt;\"vnoremap $2 &lt;esc&gt;`&gt;a]&lt;esc&gt;`&lt;i[&lt;esc&gt;\"vnoremap $3 &lt;esc&gt;`&gt;a&#125;&lt;esc&gt;`&lt;i&#123;&lt;esc&gt;\"vnoremap $$ &lt;esc&gt;`&gt;a\"&lt;esc&gt;`&lt;i\"&lt;esc&gt;\"vnoremap $q &lt;esc&gt;`&gt;a'&lt;esc&gt;`&lt;i'&lt;esc&gt;\"vnoremap $e &lt;esc&gt;`&gt;a\"&lt;esc&gt;`&lt;i\"&lt;esc&gt;\"光标在窗口之间跳动nnoremap &lt;TAB&gt;h &lt;C-w&gt;hnnoremap &lt;TAB&gt;j &lt;C-w&gt;jnnoremap &lt;TAB&gt;k &lt;C-w&gt;knnoremap &lt;TAB&gt;l &lt;C-w&gt;lmap &lt;C-A&gt; &lt;Esc&gt;ggVG\"\"noremap &lt;tab&gt; :bp&lt;CR&gt;&gt;nnoremap 9 $vmap 9 $nnoremap U &lt;C-b&gt;nnoremap D &lt;C-f&gt;nnoremap ma :nnoremap wk :res +1&lt;cr&gt;nnoremap wj :res -1&lt;cr&gt;nnoremap wl :vertical res +1&lt;cr&gt;nnoremap wh :vertical res -1&lt;cr&gt;“从网络大神中学习得到\"大神博客 http://www.vimer.cn/archives/756.htmlfunction! CheckSyntax() if &amp;filetype!=\"php\" echohl WarningMsg | echo \"Fail to check syntax! Please select the right file!\" | echohl None return endif if &amp;filetype==\"php\" \"Check php syntax setlocal makeprg=php\\ -l\\ -n\\ -d\\ html_errors=off\\ % \"Set shellpipe setlocal shellpipe=&gt; \"Use error format for parsing PHP error output setlocal errorformat=%m\\ in\\ %f\\ on\\ line\\ %l endif redir =&gt; result execute \"silent make %\" set makeprg=make redir END execute \"normal:\" if (stridx(result, 'No syntax errors detected') == -1) execute \"copen\" endif endfunctionautocmd BufWritePost *.php call CheckSyntax()nmap &lt;F4&gt; :!php %&lt;cr&gt;\" lookupfile.vim 插件设置\"--------------------------------------------------------------------------let g:LookupFile_MinPatLength = 2 \"最少输入2个字符才开始查找let g:LookupFile_PreserveLastPattern = 0 \"不保存上次查找的字符串let g:LookupFile_PreservePatternHistory = 1 \"保存查找历史let g:LookupFile_AlwaysAcceptFirst = 1 \"回车打开第一个匹配项目let g:LookupFile_AllowNewFiles = 0 \"不允许创建不存在的文件let g:LookupFile_SortMethod = \"\" \"关闭对搜索结果的字母排序nmap find :LookupFile&lt;cr&gt;\"直接打开php代码折叠，&#123;&#125;就能被折叠let php_folding = 1\"设置折叠，只要代码两边有/*&#123;&#123;&#123;*/和/*&#125;&#125;&#125;*/，就会被自动折叠。set foldmethod=markerset mouse=a\"设置没有备份set nobackup\"设置不产生wap文件set noswapfile\"set updatetime=23000\"set updatecount=400\"去除vim的GUI版本中的toolbar\"set guioptions-=T\"设置solarized主题if has('gui_running') set background=lightelse set background=darkendifcolorscheme solarized\"用vi把文件重新打开，如何回到上次光标的位置autocmd BufReadPost *\\ if line(\"'\\\"\") &gt; 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") |\\ exe \"normal g`\\\"\" |\\ endif\":abbr test public function test()&#123;&lt;cr&gt;&lt;cr&gt;&#125;\"瞬间输出时间戳nmap &lt;F3&gt; a&lt;C-R&gt;=strftime(\"%Y-%m-%d %a %I:%M %p\")&lt;CR&gt;&lt;Esc&gt;imap &lt;F3&gt; &lt;C-R&gt;=strftime(\"%Y-%m-%d %a %I:%M %p\")&lt;CR&gt;\"copy到系统剪切板\"vmap \"+y :w !pbcy&lt;CR&gt;&lt;CR&gt; vmap t :w !pbcopy&lt;CR&gt;&lt;CR&gt; \"下面这个貌似不太好使。。nmap \"+p :r !pbpaste&lt;CR&gt;&lt;CR&gt;nnoremap t yy0v9nnoremap ca ggvGt\"不知道这个是个什么鬼，据说能做diffif !exists(\":DiffOrig\") command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis \\ | wincmd p | diffthis endif\"再也不用担心缓存文件了，直接编辑。。augroup NoSimultaneousEditsautocmd!autocmd SwapExists * :let v:swapchoice = 'e'augroup END\"据说可以搞定输入法，在退出编辑模式的时候默认关掉输入法\"let g:input_toggle = 1\"function! Fcitx2en()\" let s:input_status = system(\"fcitx-remote\")\" if s:input_status == 2\" let g:input_toggle = 1\" let l:a = system(\"fcitx-remote -c\")\" endif\"endfunction\"\"function! Fcitx2zh()\" let s:input_status = system(\"fcitx-remote\")\" if s:input_status != 2 &amp;&amp; g:input_toggle == 1\" let l:a = system(\"fcitx-remote -o\")\" let g:input_toggle = 0\" endif\"endfunction\"\"set timeoutlen=150\"autocmd InsertLeave * call Fcitx2en()\"\"autocmd InsertEnter * call Fcitx2zh()","tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"vim使用技巧","date":"2016-07-29T11:32:01.000Z","path":"2016/07/29/vim使用技巧/","text":"","tags":[]},{"title":"vim语法简单整理","date":"2016-07-29T09:19:22.000Z","path":"2016/07/29/vim语法整理/","text":"基本概念 vim事件机制 每一次在vim中的操作，无论是在插入模式下还是在正常模式下，每次输入，对于vim来说就是一个事件。因此，你可以在这个时机插入钩子，让vim做你想让他做的事情。 vim内置函数 vim中内置很多系统函数，比如操作字符串的函数，eg: match() 返回一个搜索在一个字符串中出现的位置。如果想看vim中的函数，:help function-list推荐一个大神的bolg，对函数的列举和使用非常详细：大神博客传送门 vim窗口相关函数 winnr() 当前窗口号bufname() 传入数字，获取buf的名称bufnr() 传入数字，获取buf窗口的数字bufwinnr() 输出指定buf所在的窗口号winsaveview() 函数保存窗口的一些信息 vim变量 “b:”——只对当前缓冲区（buffer）有效的变量；“w:”——只对当前编辑窗口（window）有效的变量。“g:”——全局变量（在函数中访问全局变量必须使用该前缀，不加前缀的话则认为是函数内的局部变量）；“s:”——变量名只在当前脚本中有效；“a:”——函数的参数；“v:”——Vim 内部预定义的特殊变量（参见“:help vim-variable”）。 函数 &quot;注意，函数名，首字母一定要大写 function Xasdfas() endfunction 语法规则 if endif for endfor while endwhile 参考转载网页链接&amp;book vim-handbook-cn-71.pdfIBM系列文档大神博客-常用内置函数","tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"css","date":"2016-07-28T17:18:47.000Z","path":"2016/07/29/css选择器/","text":"css简介 选择器 属性声明 .hehe{ 属性1; 属性2; } 浏览器私有属性 语法说明 1margin :[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125; 基本元素 关键字=》 auto solid bold 基本类型=》 length percentage colour 其他类型 &lt;padding-with&gt; 符号 分割属性值用/ inherit initial 组合符号 空格隔开基本类型 链接的属性必须出现，而且顺序一致 &amp;&amp; 属性也一定要出现，但是顺序不保证 || 至少出现一个，顺序没有关系 | 两个只能出现一个 [] 用于分组的作用 数量符号 无 说明只出现一次 + 一个或者多个 ？ 一个或者多个，相当于可选 {} 表示基本元素出现的次数区间 * 0次1次或者多次 # 表示出现一次或者多次，中间需要用逗号来隔开 @规则 @media 媒体相应布局@+标识符+@+标识符+内容+{} css 选择器=》表达式=》选中一系列的元素分类： 组合选择器 类选择器 =》 .special{color:red;} 标签选择器 =》 p{color:blue;} id选择器 =》 #banner{color:black;} 通配符选择器 =》 *{color:green;} 属性选择器 =》 [disabled]{background-color:#eee;} [type=button]{color:blue;} [class ~=sports]{} 包含 [lang!=en]{} [href ^=&quot;#&quot;]{} [href $=pdf]{} 以pdf结尾 [href *=&quot;163&quot;]{} 包含 伪类选择器 以冒号开头,其实就是针对一些标签的一些特殊情况 a:link a:visited a:hover ... i:nth_child(even)","tags":[{"name":"前端web","slug":"前端web","permalink":"http://yoursite.com/tags/前端web/"}]},{"title":"php-变量结构","date":"2016-03-30T22:10:53.000Z","path":"2016/03/31/php-变量结构/","text":"整体结构：_zval_struct php作为一个弱类型语言。通过一个通用的数据格式存储所有变量。 123456typedef struct _zval_struct &#123; z_value value; //存储真实的值 zend_unit ref_count__gc; //引用计数 zend_uchar type; //类型 zend_uchar is_ref__gc; //是否被引用,0、1&#125; 在php5.3 引入新的垃圾回收机制之后，变量名修改为： refcount =&gt; ref_count__gc is__ref =&gt; is_ref__gc 变量的类型包括：IS_NULL、IS_BOOL、 IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE 等 上面的数据结构基本上给出了变量的顶级结构，用于语言层面。接下来就具体看看内部的一些数据结构。 变量值的存储：z_value 1234567891011typedef union _z_value&#123; long lval; double dval; struct &#123; char *val; //c中的字符串，以\\0结尾 int len; //存储字符串的长度 &#125;str; HashTable *ht; //哈希，存储数组 zend_object_value obj;&#125; 显然，这里用union这种结构是为了节省空间。这里包含的类型就有：长整形、double类型、字符串类型、hash类型（数组）、类对象。 这里hashtable类型和类类型，又有自己专门的数据结构负责。 1、PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。2、类对象保存方式 123 typedef struct _zend_object_value &#123; zend_object_handle handle; //unsigned int类型,EG(objects_store).object_buckets的索引 zend_object_handlers *handlers; &#125; zend_object_value; PHP的对象只有在运行时才会被创建,EG宏,这是一个全局结构体用于保存在运行 时的数据。 其中就包括了用来保存所有被创建的对象的对象池,EG(objects_store),而object对象值内容 的zend_object_handle域就是当前 对象在对象池中所在的索引,handlers字段则是将对象进行操作时的处 理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry。 hash的实现hash的实现需要解决三个问题： 1. 实现哈希函数 2. 冲突的解决 3. 操作接口的实现 hash函数很多，这里暂不讨论；冲突的解决，基本就是链表法或者开放寻址法；接口基本就是增删改查。 注：PHP中的哈希表实现在Zend/zend_hash.c。 hashtable结构体如下： 1234567891011121314151617181920typedef struct _hashtable&#123; uint nTableSize; //hash bucket的大小，2的n次方 uint nTableMask; //掩码，2的n次方减1，其实就是做与操作 uint nNumberOfElements; //hash Bucket中当前存在的元素个数,count()函数会直接返回此值 ulong nNextFreeElement; //下一个数字索引的位置 Bucket *pInternalPointer; //当前遍历的指针(foreach比for快的原因之一) Bucket *pListHead; //储数组头元素指针 Bucket *pListTail; //存储数组尾元素指针 Bucket **arBuckets; //存储hash数组 dtor_func_t pDestructor; // 在删除元素时执行的回调函数,用于资源的释放 zend_bool persistent; //指出了Bucket内存分配的方式。如果persisient为 TRUE,则使用操作系统本身的内存分配函数为Bucket分配内存,否则使用PHP的内存分配函数。 unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数(防止多次递 归) zend_bool bApplyProtection; // 标记当前hash桶允许不允许多次访问,不允许时,最多只 能递归3次#if ZEND_DEBUG int inconsistent;#endif&#125; bucket 数据结构： 12345678 typedef struct bucket &#123; ulong h; uint nKeyLength; void *pData; pDataPtr void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char arKey[1]; &#125; Bucket;","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php函数- array","date":"2016-03-10T23:30:12.000Z","path":"2016/03/11/php函数 array/","text":"php函数 arrayarray_change_key_case()：把数组中所有键更改为小写或大写 array_change_key_case(array,case); array： 数组 case：选项 CASE_LOWER - 默认值。将数组的键转换为小写字母。 CASE_UPPER - 将数组的键转换为大写字母。 注：如果在运行该函数时两个或多个键相同，则最后的元素会覆盖其他元素. array_chunk(): 把数组分割为新的数组块 array_chunk(array,size,preserve_key); array: 带切割数组。 size: 整数值，规定每个新数组包含多少个元素。 preserve_key: 可选 true - 保留原始数组中的键名。 false - 默认。每个结果数组使用从零开始的新数组索引。 array_column(): 返回输入数组中某个单一列的值 array_column(array,column_key,index_key); array: 数组 column_key: 需要返回列的值 index_key: 可选。用作返回数组的索引/键的列。 array_combine()： 函数通过合并两个数组来创建一个新数组。 array_combine(keys,values); keys: 数组。 values: 数组。 array_count_values(): 用于统计数组中所有值出现的次数. &lt;?php $a=array(&quot;A&quot;,&quot;Cat&quot;,&quot;Dog&quot;,&quot;A&quot;,&quot;Dog&quot;); print_r(array_count_values($a)); ?&gt; Array ( [A] =&gt; 2 [Cat] =&gt; 1 [Dog] =&gt; 2 ) array_filter(): 函数用回调函数过滤数组中的值. array_filter(array,callbackfunction); array_flip(): 函数用于反转/交换数组中所有的键名以及它们关联的键值。 array_unshift(): 函数用于向数组插入新元素。新数组的值将被插入到数组的开头。","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php内核-开篇","date":"2016-03-10T23:30:12.000Z","path":"2016/03/11/php内核-开篇/","text":"","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"CModule类","date":"2016-03-05T20:35:52.000Z","path":"2016/03/06/CModule类/","text":"CModule.php 成员变量： 1. $preload=array(); 2. $behaviors=array(); 3. $_modules=array(); 4. $_moduleConfig=array(); 5. $_components=array(); 6. $_componentConfig=array(); 成员函数： 1234567891011121314public function setComponents($components,$merge=true)&#123;foreach($components as $id=&gt;$component) &#123; if($component instanceof IApplicationComponent) $this-&gt;setComponent($id,$component); //初始化过程中，基本就调用下面的分支。 //会有merge的原因，在与yii注册核心组件和用户自定义配置中可能有重叠的组件，这里把两个配置给merge一下，反正这里是放到数组中去，只有在getComponent的时候，才会新建对象，并调用init初始化方法。 else if(isset($this-&gt;_componentConfig[$id]) &amp;&amp; $merge) $this-&gt;_componentConfig[$id]=CMap::mergeArray($this-&gt;_componentConfig[$id],$component); else $this-&gt;_componentConfig[$id]=$component; &#125;&#125; 存在父类CComponent中的魔术方法 123456789//在初始化的过程中，非事件方法，基本上就只运行到了这些代码。//事件的话会在这里放到_m数组中。 public function __get($name) &#123; $getter='get'.$name; if(method_exists($this,$getter)) return $this-&gt;$getter(); ... &#125;","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]},{"title":"CApplication类","date":"2016-03-05T20:18:15.000Z","path":"2016/03/06/CApplication类/","text":"CApplication成员变量: 1. _id 2. _basePath 3. _runtimePath 4. _extensionPath 5. _globalState 6. _stateChanged 7. ended=false 8. _language 9. _homeUrl 成员函数：123456789101112131415161718192021222324252627282930313233343536373839abstract public function processRequest();public function __construct($config=null) &#123; ... // set basePath at early as possible to avoid trouble $this-&gt;setBasePath($config['basePath']); Yii::setPathOfAlias('application',$this-&gt;getBasePath()); Yii::setPathOfAlias('webroot',dirname($_SERVER['SCRIPT_FILENAME'])); Yii::setPathOfAlias('ext',$this-&gt;getBasePath().DIRECTORY_SEPARATOR.'extensions'); $this-&gt;preinit(); //Initializes the class autoloader and error handlers $this-&gt;initSystemHandlers(); //Registers the core application components. //eg:CUrlManager、CHttpRequest $this-&gt;registerCoreComponents(); //读取配置文件，代码在基类CModule中 //foreach($config) $this-&gt;$key=$value $this-&gt;configure($config); $this-&gt;attachBehaviors($this-&gt;behaviors); $this-&gt;preloadComponents(); $this-&gt;init(); &#125; //应用开始运行，入口。 public function run() &#123; if($this-&gt;hasEventHandler('onBeginRequest')) $this-&gt;onBeginRequest(new CEvent($this)); $this-&gt;processRequest(); if($this-&gt;hasEventHandler('onEndRequest')) $this-&gt;onEndRequest(new CEvent($this)); &#125;","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]},{"title":"CWebAppliaction类","date":"2016-03-05T20:14:05.000Z","path":"2016/03/06/CWebAppliaction类/","text":"CWebApplication.php 成员变量： 1. $defaultController=&apos;site&apos;; 2. $controllerMap=array(); 3. $catchAllRequest; 4. $_controllerPath; 5. $_viewPath; 6. $_controller; 成员函数：123456789101112131415161718192021222324252627282930313233343536373839404142public function processRequest() &#123; //每一次客户端请求的入口，执行： 1. 通过url组件获取最终路由 $route=$this-&gt;getUrlManager()-&gt;parseUrl($this-&gt;getRequest()); 2. 创建对应的controller $this-&gt;runController($route); 3. 执行对应的action，在runController方法中。 $controller-&gt;run($actionID);&#125;public function runController($route)&#123; //创建controller，执行$controller-&gt;run($actionID); ...&#125;public function createController($route,$owner=null)&#123; //这个方法至关重要！！！这里传入的$route路径，表示访问的地址。方法通过$route确定controller/action //以下说明：controller文件夹下支持子目录、类名自动首字母大写 ... $caseSensitive=$this-&gt;getUrlManager()-&gt;caseSensitive; while(($pos=strpos($route,'/'))!==false) &#123; ... $className=ucfirst($id).'Controller'; $classFile=$basePath.DIRECTORY_SEPARATOR.$className.'.php'; if(is_file($classFile)) ... &#125;&#125;protected function registerCoreComponents()&#123; //注册核心组件 ... $this-&gt;setComponents($components);&#125;protected function init() &#123; parent::init(); // preload 'request' so that it has chance to respond to onBeginRequest event. $this-&gt;getRequest(); &#125;","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]},{"title":"yiiBase文件","date":"2016-03-05T20:13:40.000Z","path":"2016/03/06/yiiBase文件/","text":"YiiBase.php注：Yii类只是单纯的继承了YiiBase,什么都没干。12345678910111213141516171819202122class Yii extends YiiBase.php&#123;&#125;``` 成员变量： 1. _includePaths 2. _app 3. _logger 4. classMap 5. enableIncludePath 6. _aliases 7. _imports 8. static $_coreClasses=array(...) &lt;!--more--&gt; 应用级别成员函数：```php public static function createApplication($class,$config=null) &#123; return new $class($config); &#125; public static function createConsoleApplication($config=null) &#123; ... &#125; public static function createWebApplication($config=null) &#123; return self::createApplication('CWebApplication',$config) &#125; //导入类文件，或者路径 public static function import($alias,$forceInclude=false) &#123; ... &#125; spl_autoload_register(array('YiiBase','autoload')); require(YII_PATH.'/base/interfaces.php');","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]},{"title":"yii初始化过程架构","date":"2016-03-05T19:20:57.000Z","path":"2016/03/06/yii初始化过程架构/","text":"//应用入口 Yii::createWebApplication($config)-&gt;run(); 涉及到的一些文件： Yii.php YiiBase.php CWebApplication.php CApplication.php CModule.php CComponent.php CHttpRequest.php CUrlManager.php CController.php CAction.php 类继承关系： 初始化流程： 创建CWebApplication类对象。调用构造函数（实际调用了父类的构造函数）。 设置一些basepath路径等类变量。 初始化yii预定义核心基础组件。 读入配置文件，将信息保存到对应的数据结构中。 preload提前load一些组件。 执行CWebAppliaction类run方法。 处理预定义事件 执行processRequest 1) 读入访问的url，通过路由组件，获得最终的路由。 2) 通过路由确定对应的controller 以及action。 3) 根据配置，创建filter，执行filter 以及 action对应的方法。","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]},{"title":"yii 路由过程","date":"2016-03-01T15:45:35.000Z","path":"2016/03/01/yii网页应用初始化过程/","text":"12//应用入口Yii::createWebApplication($config)-&gt;run(); 1、yiiBase.php中相关内容 成员变量： 1. _includePaths 2. _app 3. _logger 4. classMap 5. enableIncludePath 6. _aliases 7. _imports 8. static $_coreClasses=array(...) 应用级别成员函数： 12345678910111213public static function createApplication($class,$config=null)&#123; return new $class($config);&#125;public static function createConsoleApplication($config=null)&#123; ...&#125;public static function createWebApplication($config=null)&#123; //新建CWebApp lication类对象。 return self::createApplication('CWebApplication',$config)&#125; 功能级别几个重要的成员函数：12345678910111213141516171819public static function autoload($className)&#123; //类似于魔术方法，框架主动load一些类文件，避免代码中使用include类方法。 ...&#125;public static function import($alias,$forceInclude=false)&#123; //导入类文件或者文件夹，这里应该不支持递归目录。 //这里貌似还有别名相关 //会初始化classMap成员变量。 ...&#125;public static function createComponent($config)&#123; //创建对应的component，config可以为string或者array。作为类名或传入参数。 ...&#125;``` 2、CWebApplication.php 网页应用。构造函数，初始化过程 成员变量： 1. $defaultController=&apos;site&apos;; 2. $controllerMap=array(); 3. $catchAllRequest; 4. $_controllerPath; 5. $_viewPath; 6. $_controller; 成员函数： 1234567891011121314151617181920212223242526272829303132333435363738394041public function processRequest() &#123; //每一次客户端请求的入口，执行： 1. 通过url组件获取最终路由 $route=$this-&gt;getUrlManager()-&gt;parseUrl($this-&gt;getRequest()); 2. 创建对应的controller $this-&gt;runController($route); 3. 执行对应的action，在runController方法中。 $controller-&gt;run($actionID);&#125;public function runController($route)&#123; //创建controller，执行$controller-&gt;run($actionID); ...&#125;public function createController($route,$owner=null)&#123; //这个方法至关重要！！！这里传入的$route路径，表示访问的地址。方法通过$route确定controller/action //以下说明：controller文件夹下支持子目录、类名自动首字母大写 ... $caseSensitive=$this-&gt;getUrlManager()-&gt;caseSensitive; while(($pos=strpos($route,'/'))!==false) &#123; ... $className=ucfirst($id).'Controller'; $classFile=$basePath.DIRECTORY_SEPARATOR.$className.'.php'; if(is_file($classFile)) ... &#125;&#125;protected function registerCoreComponents()&#123; //注册核心组件 ...&#125;protected function init()&#123; parent::init(); // preload 'request' so that it has chance to respond to onBeginRequest event. $this-&gt;getRequest();&#125; 3、父类 CApplication成员变量：123456789private $_id;private $_basePath;private $_runtimePath;private $_extensionPath;private $_globalState;private $_stateChanged;private $_ended=false;private $_language;private $_homeUrl; 成员函数：1234567891011121314151617181920212223abstract public function processRequest();public function __construct($config=null)&#123; ...// set basePath at early as possible to avoid trouble.preinit(). $this-&gt;initSystemHandlers();//初始化错误处理和autoload。 //注册预定义组件eg:CUrlManager、CHttpRequest。其实就是放到数组中。 $this-&gt;registerCoreComponents();//注册预定义组件eg:CUrlManager、CHttpRequest。其实就是放到数组中。 //读取配置文件，代码在基类CModule中:foreach($config) $this-&gt;$key=$value,这里调用底层CModule中的魔术方法__setter。 $this-&gt;configure($config); $this-&gt;attachBehaviors($this-&gt;behaviors);//事件啥的注册，行为啥的放到数组_m _e中。 $this-&gt;preloadComponents();//其实就是初始化preload数组中的组件，新建对象放到数组中。 $this-&gt;init();//其实没干啥&#125;//应用开始运行，入口。public function run()&#123; if($this-&gt;hasEventHandler('onBeginRequest')) $this-&gt;onBeginRequest(new CEvent($this)); $this-&gt;processRequest(); if($this-&gt;hasEventHandler('onEndRequest')) $this-&gt;onEndRequest(new CEvent($this));&#125;","tags":[{"name":"yii","slug":"yii","permalink":"http://yoursite.com/tags/yii/"}]}]